Intro problem solving
TimeComplexity
Intro to Arrays
Prefix sum
CarryForward
Subarrays
2D metrices
Sorting Basics
HashingBasics
StringBasics
Bit Manipulation Basics
Interview Problems
Contest[Covers Full Intermediate DSA]


Today's content
-Count the factors
-Optimization for counting the factors
-Check if a number is prime
-sum of N Natural Numbers
-Definition of AP and GP
-How to find the number of a times piece of code runs i.e. number of iterations
-How to compare two algorithms


what is factor?
  i is factor of N ? that means N%i==0, i divide N completely

  N factors: 1 is smallest factor
             N is largest factor

  function countFactor(N){
  count =0;
  for i-> 1to N;
  if N%i==0
  count++
  return count;
  }

  above pseudo code require N iteration

  Standard online system having 10^8 iterations in 1 sec.

  N     iterations    Time
  10^8    10^8         1sec
  10^9    10^8         1sec * 10=10sec
  10^18    10^18         1sec * 10^10= approx. 317years


  Optimization:

  i*j=N {i and j are factors of N}
  6*3=18 {6 and 3 are factors of 18}
  7*4=28 {7 and 4 are factors of 28}

  i*j=N
  j=N/i

  This means i & N/i are factors of N

  N=24

  i     N/i
  1     24
  2     12
  3     8
  4     6
  ------------------
  6     4
  8     3
  12    2
  24    1

  i<=N/i
  i^2<=N
  i<=root(N)
N=24, root(24) .ie 4.xyz, iteration till 4
N=100, root(100) i.e 10 , iteration till 10

N=40
loop 1 to 6(root 40)

i       count      factors
1       +2          1 & 40
2       +2          2 & 20
4       +2          4 & 10
5       +2          5 & 8

optimize code:

function countFactor(N){
count=0;
  for(i to root(N)){
    if(N%i==0){
      count+=2;
    }
  }
  return count;
}
This above code having issue for perfect square number like 100.
N=100

i     Count     factors
1     +2        1 & 100
2     +2        2 & 50
4     +2        4 & 25
5     +2        5 & 20
10     +2        10 & 10  // here both 10 and 10 are same number , counting +2 not work

correct optimize code:
function countFactor(N){
count=0;
  for(i to root(N) || 1 to i*i<=N){ // either root(N) or i*i<=N
    if(N%i==0){
      if(i==N/i){
        count++;
        }
      else{
        count+=2;
        }
    }
  }
  return count;
}

with optimize code:

N      iteration      time
10^8    10^4          0.5 1sec
10^9    10^4.5        5 sec
10^18   10^9          10 sec

instead of using inbuild lib for root N we can do i*i<=N
-----------------------------------------
calculate sum 1+2+3+....+100

sum=1   +  2  + 3   + ... +100
sum=100 + 99  + 98  + ... +1
---------------------------------
2sum=101+101+101+...+101

2sum=101*100

sum=(101*100)/2

sum of N Numbers:
sum=1   +  2  + 3    + ... +N
sum=N +   N-1 + N-2  + ... +1
---------------------------------
2sum=(N+1)+(N+1)+(N+1)+...+(N+1)

2sum=(N+1)*N

sum=((N+1)*N)/2

--------------------------------------------------------------------
some basic math properties
[a,c] a,b,c
(a,c) b

[a,c]  This type of range means that a & c are both inclusive.
(a,c) This type of range means that a & c are both excluded.

[a,c] c-a+1

for(i to N){

}
[1 to N] : N-1+1=N
----------------------------------------------------------------------

Geometric Progression (GP): the ratio between any consecutive is same
5 10  20  40  80  -> series to this type is GP means ratio is exact same

5         10          20          40          80
  10/5=2     20/10=2     40/20=2     80/40=2
  here ratio(r)=2 // this 2 also called common ratio

Generic Notation:
  a  ar  ar^2  ar^3 ....
    r   r     r

  Q. Given N terms of GP then what is sum?
    sum=>a((r^n)-1)/r-1 where r!=1
          a*n where r=1: a a a a....n here ratio is 1
    for 5 10 20 40 80:
    a=5, r=2, n=5(total number)
    a(r^n-1)/r-1 where r!=1 : 5((2^5)-1)/2-1 : 5*(32-1)/1 : 5*31 :155

Arithmetic Progression (AP): the difference between any consecutive is same
2 4 6 8 10 : difference is 2
sum=n/2(2a+(n-1)d)  : d is difference, a is 1st term, n is total number of terms
----------------------------------------------------------

we cannot evaluate algorithms performance using execution time as it depends on a lot of
factors like OS , place of execution, programming language etc.

comparing two algorithms who's measure does not depend on any factor is
calculating number of iteration.

The number of iterations of an algorithm remains the same irrespective of OS, Place of
execution, programming language etc.

----------------------------------------------------------

Next class:
  big O
  logarithms
  space Complexity
  Time Limit exceed (TLE) error
  importance of constraints
